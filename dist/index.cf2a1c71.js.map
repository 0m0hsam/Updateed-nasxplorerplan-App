{"mappings":"AE+CO,eAAe,EACpB,CAAU,CACV,CAAa,CACb,CAAI,CACJ,CAAQ,CACR,EAAW,OAAO,CAClB,EAAQ,CAAA,CAAI,EAER,GACF,CAAA,EAAc,SAAA,CAAY,EAD5B,EAGA,IAAM,EAAa,MAAM,EAAW,GACpC,EAAc,kBAAA,CAAmB,EAAU,GACvC,GACF,EAAS,EAEb,CAEA,SAAS,EAAa,CAAI,EAExB,OAAO,iBACL,IAAM,EAAM,MAAM,MAAM,GACxB,GAAI,EAAI,EAAA,CAAI,CACV,IAAM,EAAO,MAAM,EAAI,IAAvB,GACA,OAAO,CACT,CACF,CACF,EDxEA,AC0EO,iBAIL,IAAM,EAAmB,EAAa,2BAChC,EAAmB,EAAa,2BAChC,EAAW,SAAS,aAAA,CAAc,gBAClC,EAAW,SAAS,aAAA,CAAc,gBACxC,EAAmB,EAAkB,GACrC,EAAmB,EAAkB,EACvC","sources":["<anon>","src/js/index.js","src/js/utils.mjs"],"sourcesContent":["// wrapper for querySelector...returns matching element\nfunction $2a0a9d2c002157bd$export$836aee6bce45247(selector, parent = document) {\n    return parent.querySelector(selector);\n}\nfunction $2a0a9d2c002157bd$export$d3720feff416e85b(key) {\n    return JSON.parse(localStorage.getItem(key));\n}\nfunction $2a0a9d2c002157bd$export$1f73f60bdb811cb1(key, data) {\n    localStorage.setItem(key, JSON.stringify(data));\n}\nfunction $2a0a9d2c002157bd$export$35b87879ba45a985(selector, callback) {\n    $2a0a9d2c002157bd$export$836aee6bce45247(selector).addEventListener(\"touchend\", (event)=>{\n        event.preventDefault();\n        callback();\n    });\n    $2a0a9d2c002157bd$export$836aee6bce45247(selector).addEventListener(\"click\", callback);\n}\nfunction $2a0a9d2c002157bd$export$eb2ccaa622227397(templateFn, parentElement, list, position = \"afterbegin\", clear = true) {\n    if (clear) parentElement.innerHTML = \"\";\n    const htmlString = list.map(templateFn);\n    parentElement.insertAdjacentHTML(position, htmlString.join(\"\"));\n}\nfunction $2a0a9d2c002157bd$export$ecf541e09a511845(param) {\n    const queryString = window.location.search;\n    const urlParams = new URLSearchParams(queryString);\n    const product = urlParams.get(param);\n    return product;\n}\nasync function $2a0a9d2c002157bd$export$16b3ba5fff8817e(templateFn, parentElement, data, callback, position = \"begin\", clear = true) {\n    if (clear) parentElement.innerHTML = \"\";\n    const htmlString = await templateFn(data);\n    parentElement.insertAdjacentHTML(position, htmlString);\n    if (callback) callback(data);\n}\nfunction $2a0a9d2c002157bd$var$loadTemplate(path) {\n    // wait what?  we are returning a new function? this is called currying and can be very helpful.\n    return async function() {\n        const res = await fetch(path);\n        if (res.ok) {\n            const html = await res.text();\n            return html;\n        }\n    };\n}\nasync function $2a0a9d2c002157bd$export$a865117f198fadd2() {\n    // header template will still be a function! But one where we have pre-supplied the argument.\n    // headerTemplate and footerTemplate will be almost identical, but they will remember the path we passed in when we created them\n    // why is it important that they stay functions?  The renderWithTemplate function is expecting a template function...if we sent it a string it would break, if we changed it to expect a string then it would become less flexible.\n    const headerTemplateFn = $2a0a9d2c002157bd$var$loadTemplate(\"../partials/header.html\");\n    const footerTemplateFn = $2a0a9d2c002157bd$var$loadTemplate(\"../partials/footer.html\");\n    const headerEl = document.querySelector(\"#main-header\");\n    const footerEl = document.querySelector(\"#main-footer\");\n    $2a0a9d2c002157bd$export$16b3ba5fff8817e(headerTemplateFn, headerEl);\n    $2a0a9d2c002157bd$export$16b3ba5fff8817e(footerTemplateFn, footerEl);\n}\n\n\n(0, $2a0a9d2c002157bd$export$a865117f198fadd2)(); // const name = document.querySelector('#speak').value;\n // console.log(name);\n // const {spawn} = require('child_process');\n // document.getElementById('send_mail').addEventListener('click'() => {\n //     spawn('node', ['./mail.js']);\n // });\n\n\n//# sourceMappingURL=index.cf2a1c71.js.map\n","import { loadHeaderFooter } from \"./utils.mjs\";\r\n\r\nloadHeaderFooter();\r\n\r\n// const name = document.querySelector('#speak').value;\r\n// console.log(name);\r\n\r\n// const {spawn} = require('child_process');\r\n\r\n// document.getElementById('send_mail').addEventListener('click'() => {\r\n//     spawn('node', ['./mail.js']);\r\n// });\r\n\r\n","// wrapper for querySelector...returns matching element\r\nexport function qs(selector, parent = document) {\r\n  return parent.querySelector(selector);\r\n}\r\n// or a more concise version if you are into that sort of thing:\r\n// export const qs = (selector, parent = document) => parent.querySelector(selector);\r\n\r\n// retrieve data from localstorage\r\nexport function getLocalStorage(key) {\r\n  return JSON.parse(localStorage.getItem(key));\r\n}\r\n// save data to local storage\r\nexport function setLocalStorage(key, data) {\r\n  localStorage.setItem(key, JSON.stringify(data));\r\n}\r\n// set a listener for both touchend and click\r\nexport function setClick(selector, callback) {\r\n  qs(selector).addEventListener(\"touchend\", (event) => {\r\n    event.preventDefault();\r\n    callback();\r\n  });\r\n  qs(selector).addEventListener(\"click\", callback);\r\n}\r\n\r\n//Render List\r\nexport function renderListWithTemplate(\r\n  templateFn,\r\n  parentElement,\r\n  list,\r\n  position = \"afterbegin\",\r\n  clear = true\r\n) {\r\n  if (clear) {\r\n    parentElement.innerHTML = \"\";\r\n  }\r\n  const htmlString = list.map(templateFn);\r\n  parentElement.insertAdjacentHTML(position, htmlString.join(\"\"));\r\n}\r\n\r\nexport function getParam(param){\r\n  const queryString = window.location.search;\r\n  const urlParams = new URLSearchParams(queryString);\r\n  const product = urlParams.get(param);\r\n  return product;\r\n}\r\n\r\n\r\nexport async function renderWithTemplate(\r\n  templateFn,\r\n  parentElement,\r\n  data,\r\n  callback,\r\n  position = \"begin\",\r\n  clear = true\r\n) {\r\n  if (clear) {\r\n    parentElement.innerHTML = \"\";\r\n  }\r\n  const htmlString = await templateFn(data);\r\n  parentElement.insertAdjacentHTML(position, htmlString);\r\n  if (callback) {\r\n    callback(data);\r\n  }\r\n}\r\n\r\nfunction loadTemplate(path) {\r\n  // wait what?  we are returning a new function? this is called currying and can be very helpful.\r\n  return async function () {\r\n    const res = await fetch(path);\r\n    if (res.ok) {\r\n      const html = await res.text();\r\n      return html;\r\n    }\r\n  };\r\n}\r\n\r\nexport async function loadHeaderFooter() {\r\n  // header template will still be a function! But one where we have pre-supplied the argument.\r\n  // headerTemplate and footerTemplate will be almost identical, but they will remember the path we passed in when we created them\r\n  // why is it important that they stay functions?  The renderWithTemplate function is expecting a template function...if we sent it a string it would break, if we changed it to expect a string then it would become less flexible.\r\n  const headerTemplateFn = loadTemplate(\"../partials/header.html\");\r\n  const footerTemplateFn = loadTemplate(\"../partials/footer.html\");\r\n  const headerEl = document.querySelector(\"#main-header\");\r\n  const footerEl = document.querySelector(\"#main-footer\");\r\n  renderWithTemplate(headerTemplateFn, headerEl);\r\n  renderWithTemplate(footerTemplateFn, footerEl);\r\n}"],"names":["$2a0a9d2c002157bd$export$16b3ba5fff8817e","templateFn","parentElement","data","callback","position","clear","innerHTML","htmlString","insertAdjacentHTML","$2a0a9d2c002157bd$var$loadTemplate","path","res","fetch","ok","html","text","headerTemplateFn","footerTemplateFn","headerEl","document","querySelector","footerEl"],"version":3,"file":"index.cf2a1c71.js.map"}